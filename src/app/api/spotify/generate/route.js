import { cookies } from 'next/headers';
import {
    fetchMe,
    fetchTopTracks,
    fetchRecentTracks,
    fetchRecommendations,
    createPlaylist,
    addTracks
} from '@/lib/spotifyApi';

import {
    removeDuplicateTracks,
    countRecentPlays,
    filterByRecentPlays,
    pickSeedTracks,
    mixTaste
} from '@/lib/playlistRules';

export const dynamic = 'force-dynamic'

export async function POST() {

    const cookieStore = await cookies()
    const token = cookieStore.get("spotify_access_token")?.value
    
    if (!token) {
        return new Response("No access token", { status: 401 })
    }

    try {

        // get user id
        const me = await fetchMe(token)
        const userId = me?.id
        if (!userId) {
            return new Response("Missing user id", { status: 400 })
        }

        // get top tracks
        const top = await fetchTopTracks(token, { time_range: "short_term", limit: 50 })
        const topTracks = top?.items || []

        // get recently played tracks
        const recent = await fetchRecentTracks(token, { limit: 50 })
        const recentTracks = recent?.items || []

        // make sure enough top tracks to use for seeds
        if (topTracks.length < 10) {
            return new Response("Not enough listening history yet", { status: 400 })
        }

        // pick seeds based off top tracks
        const closeSeeds = pickSeedTracks(topTracks, { start: 0, count: 5 })
        const exploreSeeds = pickSeedTracks(topTracks, { start: 10, count: 5 })
        
        // get recommendations with seeds and reversed seeds pool for variety and no bias
        const closeA = await fetchRecommendations(token, {seed_tracks: closeSeeds, limit: 100 })
        const closeB = await fetchRecommendations(token, {seed_tracks: [...closeSeeds].reverse(), limit: 100 })

        const exploreA = await fetchRecommendations(token, {seed_tracks: exploreSeeds, limit: 100 })
        const exploreB = await fetchRecommendations(token, {seed_tracks: [...exploreSeeds].reverse(), limit: 100 })

        // remove duplicates from recommendations
        // spread to combine the two recommendation lists
        let closeCandidates = removeDuplicateTracks([...(closeA?.tracks || []), ...(closeB?.tracks || [])])
        let exploreCandidates = removeDuplicateTracks([...(exploreA?.tracks || []), ...(exploreB?.tracks || [])])

        // get recent counts of recently played tracks
        const recentCounts = countRecentPlays(recentTracks)

        // filter by recently played so we get more new songs
        closeCandidates = filterByRecentPlays(closeCandidates, recentCounts, { threshold: 3 })
        exploreCandidates = filterByRecentPlays(exploreCandidates, recentCounts, { threshold: 3 })

        // later
        // liked songs filter
        // past gens filter
        // artist repeat limit filter
        
        let finalTracks = mixTaste({
            closeTracks: closeCandidates,
            exploreTracks: exploreCandidates,
            total: 30,
            closeRatio: 0.7,
        })

        if (finalTracks.length < 10) {
            return new Response("Not enough tracks after filtering", { status: 400 })
        }

        const today = new Date().toISOString().slice(0, 10)
        const playlistName = `Discover Daily - ${today}`

        const created = await createPlaylist(token, {
            name: playlistName,
            isPublic: false,
            description: "Generated by Discover Daily"
        })

        const playlistId = created?.id
        const playlistUrl = created?.external_urls?.spotify

        if (!playlistId) {
            return new Response("Failed to create playlist", { status: 400 })
        }

        // spotify add tracks endpoint needs uris from tracks
        const uris = finalTracks.map(track => track?.uri).filter(Boolean)
        await addTracks(token, playlistId, uris)

        // db logging of generated playlist can go here later

        return Response.json({
            playlist: { id: playlistId, url: playlistUrl, name: created?.name },
            tracks: finalTracks.map(track => ({
                id: track.id,
                uri: track.uri,
                name: track.name,
                artists: (track.artists || []).map(artist => artist.name),
        })),
    },
    { status: 200 }
)
    } catch (error) {
        return new Response(String(error.message), { status: 500 })
    }
}