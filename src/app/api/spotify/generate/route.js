import { cookies } from 'next/headers';
import { fetchMe, fetchTopTracks, fetchTopArtists, fetchRecentTracks, createPlaylist, addTracks } from '@/lib/spotifyApi';
import { fetchSeedRecommendations } from '@/lib/spotifyInternal';
import { shuffle, removeDuplicates, countRecentPlays, filterByRecentPlays, mixTaste, pickSeeds } from '@/lib/playlistRules';

export const dynamic = 'force-dynamic'

export async function POST() {

    const cookieStore = await cookies()
    const token = cookieStore.get("spotify_access_token")?.value
    
    if (!token) {
        return new Response("No access token", { status: 401 })
    }

    try {

        // get user id
        const me = await fetchMe(token)
        const userId = me?.id
        if (!userId) {
            return new Response("Missing user id", { status: 400 })
        }

        // fetch all spotify data in parallel
        const [topShortTracks, topMediumTracks, topShort, recent] = await Promise.all([
            fetchTopTracks(token, { time_range: "short_term", limit: 50 }),
            fetchTopTracks(token, { time_range: "medium_term", limit: 50 }),
            fetchTopArtists(token, { time_range: "short_term", limit: 50 }),
            fetchRecentTracks(token, { limit: 50 }),
        ])

        const shortTracks = topShortTracks?.items || []
        const mediumTracks = topMediumTracks?.items || []
        const shortArtists = topShort?.items || []
        const recentTracks = recent?.items || []

        const topArtists = shortArtists.slice(0, 30)

        if (shortTracks.length < 10 || shortArtists.length < 10) {
            return new Response("Not enough listening history yet", { status: 400 })
        }

        const closeSeeds = pickSeeds(shortTracks, 0, 25, 15)
        const exploreSeeds = pickSeeds(mediumTracks, 5, 30, 5)

        // get all radio tracks for each seed
        const [closeResults, exploreResults] = await Promise.all([
            Promise.allSettled(closeSeeds.map(t => fetchSeedRecommendations(t.uri))),
            Promise.allSettled(exploreSeeds.map(t => fetchSeedRecommendations(t.uri))),
        ])

        let closePool = closeResults.filter(r => r.status === "fulfilled").flatMap(r => r.value)
        let explorePool = exploreResults.filter(r => r.status === "fulfilled").flatMap(r => r.value)

        // remove seed tracks from pools
        const seedUris = new Set([...closeSeeds, ...exploreSeeds].map(t => t.uri))
        closePool = closePool.filter(t => !seedUris.has(t.uri))
        explorePool = explorePool.filter(t => !seedUris.has(t.uri))

        // remove duplicate tracks by uri across all radios
        const removeDuplicateTracks = (tracks) => {
            const seen = new Set()
            return tracks.filter(t => {
                if (seen.has(t.uri)) return false
                seen.add(t.uri)
                return true
            })
        }
        closePool = removeDuplicateTracks(closePool)
        explorePool = removeDuplicateTracks(explorePool)

        // shuffle pooled tracks so picks aren't biased toward first radio
        let closeCandidates = shuffle(closePool)
        let exploreCandidates = shuffle(explorePool)

        closeCandidates = removeDuplicates(closeCandidates, topArtists)
        exploreCandidates = removeDuplicates(exploreCandidates, topArtists)

        // get recent counts of recently played tracks
        const recentCounts = countRecentPlays(recentTracks)

        // filter by recently played so we get more new songs
        closeCandidates = filterByRecentPlays(closeCandidates, recentCounts, { threshold: 3 })
        exploreCandidates = filterByRecentPlays(exploreCandidates, recentCounts, { threshold: 3 })

        // later
        // liked songs filter
        // past gens filter
        // artist repeat limit filter

        let finalTracks = mixTaste({
            closeTracks: closeCandidates,
            exploreTracks: exploreCandidates,
            total: 20,
            closeRatio: 0.75,
        })

        if (finalTracks.length < 10) {
            return new Response("Not enough tracks after filtering", { status: 400 })
        }

        const today = new Date().toISOString().slice(0, 10)
        const playlistName = `Discover Daily - ${today}`

        const created = await createPlaylist(token, {
            name: playlistName,
            isPublic: false,
            description: "Generated by Discover Daily"
        })

        const playlistId = created?.id
        const playlistUrl = created?.external_urls?.spotify

        if (!playlistId) {
            return new Response("Failed to create playlist", { status: 400 })
        }

        // spotify add tracks endpoint needs uris from tracks
        const uris = finalTracks.map(track => track?.uri).filter(Boolean)
        await addTracks(token, playlistId, uris)

        // db logging of generated playlist can go here later

        return Response.json({
            playlist: { id: playlistId, url: playlistUrl, name: created?.name },
            tracks: finalTracks.map(track => ({
                id: track.id,
                uri: track.uri,
                name: track.name,
                artists: (track.artists || []).map(artist => artist.name),
        })),
    },
    { status: 200 }
)
    } catch (error) {
        return new Response(String(error.message), { status: 500 })
    }
}