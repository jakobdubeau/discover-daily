import { cookies } from 'next/headers';
import {
    fetchMe,
    fetchTopTracks,
    fetchTopArtists,
    fetchArtistRecommendations,
    fetchRecentTracks,
    searchTracks,
    createPlaylist,
    addTracks
} from '@/lib/spotifyApi';

import {
    removeDuplicates,
    countRecentPlays,
    filterByRecentPlays,
    mixTaste
} from '@/lib/playlistRules';

export const dynamic = 'force-dynamic'

export async function POST() {

    const cookieStore = await cookies()
    const token = cookieStore.get("spotify_access_token")?.value
    
    if (!token) {
        return new Response("No access token", { status: 401 })
    }

    try {

        // get user id
        const me = await fetchMe(token)
        const userId = me?.id
        if (!userId) {
            return new Response("Missing user id", { status: 400 })
        }

        // get top tracks
        const top = await fetchTopTracks(token, { time_range: "short_term", limit: 50 })
        const topTracks = top?.items || []

        // get top artists
        const topA = await fetchTopArtists(token, { time_range: "short_term", limit: 50 })
        const topArtists = topA?.items || []

        // get recently played tracks
        const recent = await fetchRecentTracks(token, { limit: 50 })
        const recentTracks = recent?.items || []

        // make sure enough top tracks to use for seeds
        if (topArtists.length < 15) {
            return new Response("Not enough listening history yet", { status: 400 })
        }

        const closeSeeds = topArtists.slice(0, 5)
        const exploreSeeds = topArtists.slice(10,15)

        const closeRelated = []
        const exploreRelated = []

        // fetch related artists for each seed into flat arrays
        for (const artist of closeSeeds) {
            try {
                const data = await fetchArtistRecommendations(token, artist.id)
                closeRelated.push(...(data?.artists || []))
            } catch { continue }
        }

        for (const artist of exploreSeeds) {
            try {
                const data = await fetchArtistRecommendations(token, artist.id)
                exploreRelated.push(...(data?.artists || []))
            } catch { continue }
        }

        // dedupe related artists, remove users top artists
        const topArtistIds = new Set(topArtists.map(a => a.id))
        const dedupeArtists = (artists) => {
            const seen = new Set()
            return artists.filter(a => {
                if (topArtistIds.has(a.id) || seen.has(a.id)) return false
                seen.add(a.id)
                return true
            })
        }

        const closeArtists = dedupeArtists(closeRelated).slice(0, 15)
        const exploreArtists = dedupeArtists(exploreRelated).slice(0, 15)

        // search for tracks by each related artist
        const searchArtistTracks = async (artists) => {
            const tracks = []
            for (const artist of artists) {
                try {
                    const data = await searchTracks(token, `artist:${artist.name}`, { limit: 10 })
                    const items = data?.tracks?.items || []
                    tracks.push(...items.map(t => ({
                        id: t.id,
                        uri: t.uri,
                        name: t.name,
                        artists: (t.artists || []).map(a => ({ name: a.name, id: a.id })),
                    })))
                } catch { continue }
            }
            return tracks
        }

        let closeCandidates = await searchArtistTracks(closeArtists)
        let exploreCandidates = await searchArtistTracks(exploreArtists)

        closeCandidates = removeDuplicates(closeCandidates, topArtists)
        exploreCandidates = removeDuplicates(exploreCandidates, topArtists)

        // get recent counts of recently played tracks
        const recentCounts = countRecentPlays(recentTracks)

        // filter by recently played so we get more new songs
        closeCandidates = filterByRecentPlays(closeCandidates, recentCounts, { threshold: 3 })
        exploreCandidates = filterByRecentPlays(exploreCandidates, recentCounts, { threshold: 3 })

        // later
        // liked songs filter
        // past gens filter
        // artist repeat limit filter
        
        let finalTracks = mixTaste({
            closeTracks: closeCandidates,
            exploreTracks: exploreCandidates,
            total: 20,
            closeRatio: 0.5,
        })

        if (finalTracks.length < 10) {
            return new Response("Not enough tracks after filtering", { status: 400 })
        }

        const today = new Date().toISOString().slice(0, 10)
        const playlistName = `Discover Daily - ${today}`

        const created = await createPlaylist(token, {
            name: playlistName,
            isPublic: false,
            description: "Generated by Discover Daily"
        })

        const playlistId = created?.id
        const playlistUrl = created?.external_urls?.spotify

        if (!playlistId) {
            return new Response("Failed to create playlist", { status: 400 })
        }

        // spotify add tracks endpoint needs uris from tracks
        const uris = finalTracks.map(track => track?.uri).filter(Boolean)
        await addTracks(token, playlistId, uris)

        // db logging of generated playlist can go here later

        return Response.json({
            playlist: { id: playlistId, url: playlistUrl, name: created?.name },
            tracks: finalTracks.map(track => ({
                id: track.id,
                uri: track.uri,
                name: track.name,
                artists: (track.artists || []).map(artist => artist.name),
        })),
    },
    { status: 200 }
)
    } catch (error) {
        return new Response(String(error.message), { status: 500 })
    }
}